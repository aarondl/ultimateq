// Code generated by protoc-gen-gogo.
// source: data.proto
// DO NOT EDIT!

/*
	Package api is a generated protocol buffer package.

	It is generated from these files:
		data.proto
		ultimateq.proto

	It has these top-level messages:
		SimpleUser
		Handler
		Command
		ChannelModes
		UserModes
		ModeKinds
		StoredUser
		StoredChannel
		Access
		SelfResponse
		Empty
		Query
		NetworkQuery
		ChannelQuery
		ListResponse
		CountResponse
		Result
		RegisterRequest
		UnregisterRequest
		UserResponse
		UserModesResponse
		ChannelResponse
		StoredUsersResponse
		StoredChannelsResponse
		LogoutRequest
		IRCMessage
		NetworkInfo
		AuthUserRequest
		RawIRC
		ConnectionDetails
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SimpleUser struct {
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *SimpleUser) Reset()                    { *m = SimpleUser{} }
func (m *SimpleUser) String() string            { return proto.CompactTextString(m) }
func (*SimpleUser) ProtoMessage()               {}
func (*SimpleUser) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{0} }

type Handler struct {
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Channel string `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel,omitempty"`
	Event   string `protobuf:"bytes,3,opt,name=event,proto3" json:"event,omitempty"`
}

func (m *Handler) Reset()                    { *m = Handler{} }
func (m *Handler) String() string            { return proto.CompactTextString(m) }
func (*Handler) ProtoMessage()               {}
func (*Handler) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{1} }

type Command struct {
	Network string       `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Channel string       `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel,omitempty"`
	Cmd     *Command_Cmd `protobuf:"bytes,3,opt,name=cmd" json:"cmd,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{2} }

func (m *Command) GetCmd() *Command_Cmd {
	if m != nil {
		return m.Cmd
	}
	return nil
}

type Command_Cmd struct {
	Network     string   `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Channel     string   `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel,omitempty"`
	Description string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Kind        int32    `protobuf:"varint,4,opt,name=kind,proto3" json:"kind,omitempty"`
	Scope       int32    `protobuf:"varint,5,opt,name=scope,proto3" json:"scope,omitempty"`
	Args        []string `protobuf:"bytes,6,rep,name=args" json:"args,omitempty"`
	RequireAuth bool     `protobuf:"varint,7,opt,name=require_auth,json=requireAuth,proto3" json:"require_auth,omitempty"`
	ReqLevel    int32    `protobuf:"varint,8,opt,name=req_level,json=reqLevel,proto3" json:"req_level,omitempty"`
	ReqFlags    string   `protobuf:"bytes,9,opt,name=req_flags,json=reqFlags,proto3" json:"req_flags,omitempty"`
}

func (m *Command_Cmd) Reset()                    { *m = Command_Cmd{} }
func (m *Command_Cmd) String() string            { return proto.CompactTextString(m) }
func (*Command_Cmd) ProtoMessage()               {}
func (*Command_Cmd) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{2, 0} }

type ChannelModes struct {
	Modes        map[string]bool                      `protobuf:"bytes,1,rep,name=modes" json:"modes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ArgModes     map[string]string                    `protobuf:"bytes,2,rep,name=arg_modes,json=argModes" json:"arg_modes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AddressModes map[string]*ChannelModes_AddressMode `protobuf:"bytes,3,rep,name=address_modes,json=addressModes" json:"address_modes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Addresses    int32                                `protobuf:"varint,4,opt,name=addresses,proto3" json:"addresses,omitempty"`
	Kinds        *ModeKinds                           `protobuf:"bytes,5,opt,name=kinds" json:"kinds,omitempty"`
}

func (m *ChannelModes) Reset()                    { *m = ChannelModes{} }
func (m *ChannelModes) String() string            { return proto.CompactTextString(m) }
func (*ChannelModes) ProtoMessage()               {}
func (*ChannelModes) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{3} }

func (m *ChannelModes) GetModes() map[string]bool {
	if m != nil {
		return m.Modes
	}
	return nil
}

func (m *ChannelModes) GetArgModes() map[string]string {
	if m != nil {
		return m.ArgModes
	}
	return nil
}

func (m *ChannelModes) GetAddressModes() map[string]*ChannelModes_AddressMode {
	if m != nil {
		return m.AddressModes
	}
	return nil
}

func (m *ChannelModes) GetKinds() *ModeKinds {
	if m != nil {
		return m.Kinds
	}
	return nil
}

type ChannelModes_AddressMode struct {
	ModeAddresses []string `protobuf:"bytes,1,rep,name=mode_addresses,json=modeAddresses" json:"mode_addresses,omitempty"`
}

func (m *ChannelModes_AddressMode) Reset()                    { *m = ChannelModes_AddressMode{} }
func (m *ChannelModes_AddressMode) String() string            { return proto.CompactTextString(m) }
func (*ChannelModes_AddressMode) ProtoMessage()               {}
func (*ChannelModes_AddressMode) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{3, 0} }

type UserModes struct {
	Kinds *ModeKinds `protobuf:"bytes,1,opt,name=kinds" json:"kinds,omitempty"`
	Modes int32      `protobuf:"varint,2,opt,name=modes,proto3" json:"modes,omitempty"`
}

func (m *UserModes) Reset()                    { *m = UserModes{} }
func (m *UserModes) String() string            { return proto.CompactTextString(m) }
func (*UserModes) ProtoMessage()               {}
func (*UserModes) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{4} }

func (m *UserModes) GetKinds() *ModeKinds {
	if m != nil {
		return m.Kinds
	}
	return nil
}

type ModeKinds struct {
	UserPrefixes []*ModeKinds_UserPrefix `protobuf:"bytes,1,rep,name=user_prefixes,json=userPrefixes" json:"user_prefixes,omitempty"`
	ChannelModes map[string]int32        `protobuf:"bytes,2,rep,name=channel_modes,json=channelModes" json:"channel_modes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ModeKinds) Reset()                    { *m = ModeKinds{} }
func (m *ModeKinds) String() string            { return proto.CompactTextString(m) }
func (*ModeKinds) ProtoMessage()               {}
func (*ModeKinds) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{5} }

func (m *ModeKinds) GetUserPrefixes() []*ModeKinds_UserPrefix {
	if m != nil {
		return m.UserPrefixes
	}
	return nil
}

func (m *ModeKinds) GetChannelModes() map[string]int32 {
	if m != nil {
		return m.ChannelModes
	}
	return nil
}

type ModeKinds_UserPrefix struct {
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Char   string `protobuf:"bytes,2,opt,name=char,proto3" json:"char,omitempty"`
}

func (m *ModeKinds_UserPrefix) Reset()                    { *m = ModeKinds_UserPrefix{} }
func (m *ModeKinds_UserPrefix) String() string            { return proto.CompactTextString(m) }
func (*ModeKinds_UserPrefix) ProtoMessage()               {}
func (*ModeKinds_UserPrefix) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{5, 0} }

type StoredUser struct {
	Username string             `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password []byte             `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Masks    []string           `protobuf:"bytes,3,rep,name=masks" json:"masks,omitempty"`
	Access   map[string]*Access `protobuf:"bytes,4,rep,name=access" json:"access,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Data     map[string]string  `protobuf:"bytes,5,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StoredUser) Reset()                    { *m = StoredUser{} }
func (m *StoredUser) String() string            { return proto.CompactTextString(m) }
func (*StoredUser) ProtoMessage()               {}
func (*StoredUser) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{6} }

func (m *StoredUser) GetAccess() map[string]*Access {
	if m != nil {
		return m.Access
	}
	return nil
}

func (m *StoredUser) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type StoredChannel struct {
	Network string            `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Name    string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Data    map[string]string `protobuf:"bytes,3,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StoredChannel) Reset()                    { *m = StoredChannel{} }
func (m *StoredChannel) String() string            { return proto.CompactTextString(m) }
func (*StoredChannel) ProtoMessage()               {}
func (*StoredChannel) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{7} }

func (m *StoredChannel) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type Access struct {
	Level uint32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Flags uint64 `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
}

func (m *Access) Reset()                    { *m = Access{} }
func (m *Access) String() string            { return proto.CompactTextString(m) }
func (*Access) ProtoMessage()               {}
func (*Access) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{8} }

func init() {
	proto.RegisterType((*SimpleUser)(nil), "api.SimpleUser")
	proto.RegisterType((*Handler)(nil), "api.Handler")
	proto.RegisterType((*Command)(nil), "api.Command")
	proto.RegisterType((*Command_Cmd)(nil), "api.Command.Cmd")
	proto.RegisterType((*ChannelModes)(nil), "api.ChannelModes")
	proto.RegisterType((*ChannelModes_AddressMode)(nil), "api.ChannelModes.AddressMode")
	proto.RegisterType((*UserModes)(nil), "api.UserModes")
	proto.RegisterType((*ModeKinds)(nil), "api.ModeKinds")
	proto.RegisterType((*ModeKinds_UserPrefix)(nil), "api.ModeKinds.UserPrefix")
	proto.RegisterType((*StoredUser)(nil), "api.StoredUser")
	proto.RegisterType((*StoredChannel)(nil), "api.StoredChannel")
	proto.RegisterType((*Access)(nil), "api.Access")
}
func (m *SimpleUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SimpleUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *Handler) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Handler) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Channel) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Channel)))
		i += copy(data[i:], m.Channel)
	}
	if len(m.Event) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(len(m.Event)))
		i += copy(data[i:], m.Event)
	}
	return i, nil
}

func (m *Command) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Command) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Channel) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Channel)))
		i += copy(data[i:], m.Channel)
	}
	if m.Cmd != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(m.Cmd.Size()))
		n1, err := m.Cmd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Command_Cmd) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Command_Cmd) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Channel) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Channel)))
		i += copy(data[i:], m.Channel)
	}
	if len(m.Description) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if m.Kind != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintData(data, i, uint64(m.Kind))
	}
	if m.Scope != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintData(data, i, uint64(m.Scope))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.RequireAuth {
		data[i] = 0x38
		i++
		if m.RequireAuth {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ReqLevel != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintData(data, i, uint64(m.ReqLevel))
	}
	if len(m.ReqFlags) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintData(data, i, uint64(len(m.ReqFlags)))
		i += copy(data[i:], m.ReqFlags)
	}
	return i, nil
}

func (m *ChannelModes) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelModes) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Modes) > 0 {
		for k, _ := range m.Modes {
			data[i] = 0xa
			i++
			v := m.Modes[k]
			mapSize := 1 + len(k) + sovData(uint64(len(k))) + 1 + 1
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			if v {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	if len(m.ArgModes) > 0 {
		for k, _ := range m.ArgModes {
			data[i] = 0x12
			i++
			v := m.ArgModes[k]
			mapSize := 1 + len(k) + sovData(uint64(len(k))) + 1 + len(v) + sovData(uint64(len(v)))
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintData(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.AddressModes) > 0 {
		for k, _ := range m.AddressModes {
			data[i] = 0x1a
			i++
			v := m.AddressModes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovData(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovData(uint64(len(k))) + msgSize
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintData(data, i, uint64(v.Size()))
				n2, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if m.Addresses != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintData(data, i, uint64(m.Addresses))
	}
	if m.Kinds != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintData(data, i, uint64(m.Kinds.Size()))
		n3, err := m.Kinds.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ChannelModes_AddressMode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelModes_AddressMode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ModeAddresses) > 0 {
		for _, s := range m.ModeAddresses {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *UserModes) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserModes) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kinds != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.Kinds.Size()))
		n4, err := m.Kinds.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Modes != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(m.Modes))
	}
	return i, nil
}

func (m *ModeKinds) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ModeKinds) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserPrefixes) > 0 {
		for _, msg := range m.UserPrefixes {
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChannelModes) > 0 {
		for k, _ := range m.ChannelModes {
			data[i] = 0x12
			i++
			v := m.ChannelModes[k]
			mapSize := 1 + len(k) + sovData(uint64(len(k))) + 1 + sovData(uint64(v))
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintData(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ModeKinds_UserPrefix) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ModeKinds_UserPrefix) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Symbol) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Symbol)))
		i += copy(data[i:], m.Symbol)
	}
	if len(m.Char) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Char)))
		i += copy(data[i:], m.Char)
	}
	return i, nil
}

func (m *StoredUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StoredUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	if len(m.Password) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	if len(m.Masks) > 0 {
		for _, s := range m.Masks {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Access) > 0 {
		for k, _ := range m.Access {
			data[i] = 0x22
			i++
			v := m.Access[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovData(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovData(uint64(len(k))) + msgSize
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintData(data, i, uint64(v.Size()))
				n5, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			data[i] = 0x2a
			i++
			v := m.Data[k]
			mapSize := 1 + len(k) + sovData(uint64(len(k))) + 1 + len(v) + sovData(uint64(len(v)))
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintData(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *StoredChannel) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StoredChannel) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			data[i] = 0x1a
			i++
			v := m.Data[k]
			mapSize := 1 + len(k) + sovData(uint64(len(k))) + 1 + len(v) + sovData(uint64(len(v)))
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintData(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *Access) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Access) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintData(data, i, uint64(m.Level))
	}
	if m.Flags != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(m.Flags))
	}
	return i, nil
}

func encodeFixed64Data(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Data(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintData(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *SimpleUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Handler) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Cmd != nil {
		l = m.Cmd.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Command_Cmd) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovData(uint64(m.Kind))
	}
	if m.Scope != 0 {
		n += 1 + sovData(uint64(m.Scope))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.RequireAuth {
		n += 2
	}
	if m.ReqLevel != 0 {
		n += 1 + sovData(uint64(m.ReqLevel))
	}
	l = len(m.ReqFlags)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ChannelModes) Size() (n int) {
	var l int
	_ = l
	if len(m.Modes) > 0 {
		for k, v := range m.Modes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovData(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	if len(m.ArgModes) > 0 {
		for k, v := range m.ArgModes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovData(uint64(len(k))) + 1 + len(v) + sovData(uint64(len(v)))
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	if len(m.AddressModes) > 0 {
		for k, v := range m.AddressModes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	if m.Addresses != 0 {
		n += 1 + sovData(uint64(m.Addresses))
	}
	if m.Kinds != nil {
		l = m.Kinds.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ChannelModes_AddressMode) Size() (n int) {
	var l int
	_ = l
	if len(m.ModeAddresses) > 0 {
		for _, s := range m.ModeAddresses {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *UserModes) Size() (n int) {
	var l int
	_ = l
	if m.Kinds != nil {
		l = m.Kinds.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Modes != 0 {
		n += 1 + sovData(uint64(m.Modes))
	}
	return n
}

func (m *ModeKinds) Size() (n int) {
	var l int
	_ = l
	if len(m.UserPrefixes) > 0 {
		for _, e := range m.UserPrefixes {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.ChannelModes) > 0 {
		for k, v := range m.ChannelModes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovData(uint64(len(k))) + 1 + sovData(uint64(v))
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ModeKinds_UserPrefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Char)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *StoredUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Masks) > 0 {
		for _, s := range m.Masks {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.Access) > 0 {
		for k, v := range m.Access {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovData(uint64(len(k))) + 1 + len(v) + sovData(uint64(len(v)))
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StoredChannel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovData(uint64(len(k))) + 1 + len(v) + sovData(uint64(len(v)))
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Access) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovData(uint64(m.Level))
	}
	if m.Flags != 0 {
		n += 1 + sovData(uint64(m.Flags))
	}
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SimpleUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Handler) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Handler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Handler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cmd == nil {
				m.Cmd = &Command_Cmd{}
			}
			if err := m.Cmd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command_Cmd) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Scope |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireAuth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireAuth = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqLevel", wireType)
			}
			m.ReqLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReqLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqFlags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqFlags = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelModes) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelModes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelModes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthData
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Modes == nil {
				m.Modes = make(map[string]bool)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvaluetemp |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				mapvalue := bool(mapvaluetemp != 0)
				m.Modes[mapkey] = mapvalue
			} else {
				var mapvalue bool
				m.Modes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgModes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthData
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ArgModes == nil {
				m.ArgModes = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthData
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.ArgModes[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.ArgModes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressModes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthData
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.AddressModes == nil {
				m.AddressModes = make(map[string]*ChannelModes_AddressMode)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthData
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthData
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &ChannelModes_AddressMode{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.AddressModes[mapkey] = mapvalue
			} else {
				var mapvalue *ChannelModes_AddressMode
				m.AddressModes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			m.Addresses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Addresses |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kinds == nil {
				m.Kinds = &ModeKinds{}
			}
			if err := m.Kinds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelModes_AddressMode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeAddresses = append(m.ModeAddresses, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserModes) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserModes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserModes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kinds == nil {
				m.Kinds = &ModeKinds{}
			}
			if err := m.Kinds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			m.Modes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Modes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModeKinds) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModeKinds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModeKinds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPrefixes = append(m.UserPrefixes, &ModeKinds_UserPrefix{})
			if err := m.UserPrefixes[len(m.UserPrefixes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelModes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthData
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ChannelModes == nil {
				m.ChannelModes = make(map[string]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChannelModes[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.ChannelModes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModeKinds_UserPrefix) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Char", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Char = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoredUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoredUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoredUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], data[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Masks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Masks = append(m.Masks, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthData
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Access == nil {
				m.Access = make(map[string]*Access)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthData
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthData
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Access{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Access[mapkey] = mapvalue
			} else {
				var mapvalue *Access
				m.Access[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthData
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Data == nil {
				m.Data = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthData
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Data[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Data[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoredChannel) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoredChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoredChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthData
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Data == nil {
				m.Data = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthData
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Data[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Data[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Access) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Access: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Access: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Flags |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("data.proto", fileDescriptorData) }

var fileDescriptorData = []byte{
	// 795 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x55, 0xcd, 0x6e, 0x33, 0x35,
	0x14, 0x65, 0x32, 0xf9, 0x9b, 0x3b, 0x49, 0xd5, 0x5a, 0x08, 0x0d, 0x69, 0x09, 0xe9, 0x00, 0x52,
	0x36, 0x44, 0x28, 0xad, 0x44, 0x05, 0x08, 0x14, 0x42, 0x4b, 0x25, 0x40, 0x42, 0x53, 0xb1, 0x25,
	0x72, 0x67, 0xdc, 0x64, 0x94, 0xf9, 0xab, 0x3d, 0x69, 0xe9, 0x43, 0xb0, 0x47, 0xe2, 0x05, 0x78,
	0x0b, 0xb6, 0x2c, 0x59, 0xb3, 0x42, 0xe5, 0x1d, 0x58, 0x7f, 0xba, 0xb6, 0x93, 0x38, 0x5f, 0xa2,
	0x56, 0x5f, 0x37, 0xd1, 0x3d, 0xd7, 0xf7, 0x9c, 0xf1, 0x3d, 0xbe, 0x76, 0x00, 0x22, 0x5a, 0xd2,
	0x41, 0xc1, 0xf3, 0x32, 0x27, 0x36, 0x2d, 0x62, 0xff, 0x14, 0xe0, 0x2a, 0x4e, 0x8b, 0x84, 0xfd,
	0x24, 0x18, 0x27, 0x04, 0xaa, 0xb3, 0x5c, 0x94, 0x9e, 0xd5, 0xb3, 0xfa, 0x4e, 0x20, 0x63, 0xcc,
	0x65, 0x34, 0x65, 0x5e, 0x45, 0xe5, 0x30, 0xf6, 0xaf, 0xa0, 0x71, 0x49, 0xb3, 0x28, 0x61, 0x9c,
	0x78, 0xd0, 0xc8, 0x58, 0x79, 0x9f, 0xf3, 0xb9, 0x66, 0x2d, 0x21, 0xae, 0x84, 0x33, 0x9a, 0x65,
	0x2c, 0xd1, 0xdc, 0x25, 0x24, 0x6f, 0x43, 0x8d, 0xdd, 0xb1, 0xac, 0xf4, 0x6c, 0x99, 0x57, 0xc0,
	0xff, 0xa7, 0x02, 0x8d, 0x71, 0x9e, 0xa6, 0x34, 0x8b, 0x5e, 0xa4, 0xea, 0x83, 0x1d, 0xa6, 0x91,
	0xd4, 0x74, 0x87, 0xfb, 0x03, 0x5a, 0xc4, 0x03, 0x2d, 0x37, 0x18, 0xa7, 0x51, 0x80, 0x8b, 0x9d,
	0xff, 0x2d, 0xb0, 0xc7, 0xe9, 0xcb, 0xf4, 0x7b, 0xe0, 0x46, 0x4c, 0x84, 0x3c, 0x2e, 0xca, 0x38,
	0xcf, 0xf4, 0xde, 0xcd, 0x14, 0x5a, 0x35, 0x8f, 0xb3, 0xc8, 0xab, 0xf6, 0xac, 0x7e, 0x2d, 0x90,
	0x31, 0xf6, 0x2a, 0xc2, 0xbc, 0x60, 0x5e, 0x4d, 0x26, 0x15, 0xc0, 0x4a, 0xca, 0xa7, 0xc2, 0xab,
	0xf7, 0x6c, 0x34, 0x15, 0x63, 0x72, 0x0c, 0x2d, 0xce, 0x6e, 0x17, 0x31, 0x67, 0x13, 0xba, 0x28,
	0x67, 0x5e, 0xa3, 0x67, 0xf5, 0x9b, 0x81, 0xab, 0x73, 0xa3, 0x45, 0x39, 0x23, 0x87, 0xe0, 0x70,
	0x76, 0x3b, 0x49, 0xd8, 0x1d, 0x4b, 0xbc, 0xa6, 0x14, 0x6c, 0x72, 0x76, 0xfb, 0x3d, 0xe2, 0xe5,
	0xe2, 0x4d, 0x42, 0xa7, 0xc2, 0x73, 0xe4, 0xee, 0x70, 0xf1, 0x02, 0xb1, 0xff, 0x7b, 0x15, 0x5a,
	0x63, 0xd5, 0xc8, 0x0f, 0x79, 0xc4, 0x04, 0x19, 0x42, 0x2d, 0xc5, 0xc0, 0xb3, 0x7a, 0x76, 0xdf,
	0x1d, 0x1e, 0x29, 0xbf, 0x8c, 0x8a, 0x81, 0xfc, 0x3d, 0xcf, 0x4a, 0xfe, 0x10, 0xa8, 0x52, 0xf2,
	0x05, 0x38, 0x94, 0x4f, 0x27, 0x8a, 0x57, 0x91, 0xbc, 0xf7, 0xb7, 0x79, 0x23, 0x3e, 0x35, 0xa8,
	0x4d, 0xaa, 0x21, 0xb9, 0x84, 0x36, 0x8d, 0x22, 0xce, 0x84, 0xd0, 0x0a, 0xb6, 0x54, 0xf8, 0x60,
	0x87, 0x82, 0x2a, 0x33, 0x54, 0x5a, 0xd4, 0x48, 0x91, 0x23, 0x70, 0x34, 0x66, 0x42, 0x9b, 0xbd,
	0x4e, 0x90, 0x0f, 0xa1, 0x86, 0xce, 0x0b, 0xe9, 0xb8, 0x3b, 0xdc, 0x93, 0xfa, 0x48, 0xfc, 0x0e,
	0xb3, 0x81, 0x5a, 0xec, 0x9c, 0x82, 0x6b, 0x7c, 0x86, 0x7c, 0x04, 0x7b, 0xb8, 0xa9, 0xc9, 0x5a,
	0xd7, 0x92, 0x47, 0xd3, 0xc6, 0xec, 0x68, 0x99, 0xec, 0x9c, 0x01, 0xac, 0x77, 0x45, 0xf6, 0xc1,
	0x9e, 0xb3, 0x07, 0x3d, 0x41, 0x18, 0xe2, 0x69, 0xdf, 0xd1, 0x64, 0xa1, 0x6e, 0x4b, 0x33, 0x50,
	0xe0, 0xb3, 0xca, 0x99, 0xd5, 0xf9, 0x1c, 0xda, 0x1b, 0xc6, 0x3c, 0x47, 0x76, 0x4c, 0xf2, 0xcf,
	0x70, 0xb0, 0xe5, 0xc9, 0x0e, 0x81, 0x13, 0x53, 0xc0, 0x1d, 0xbe, 0xf7, 0xa4, 0xb3, 0x86, 0xbe,
	0xff, 0x2d, 0x38, 0x78, 0xff, 0x95, 0xbb, 0x2b, 0xff, 0xac, 0x27, 0xfc, 0xc3, 0xcd, 0x2e, 0xe7,
	0x40, 0xce, 0xb5, 0x04, 0xfe, 0xaf, 0x15, 0x70, 0x56, 0xa5, 0xe4, 0x4b, 0x68, 0x2f, 0x04, 0xe3,
	0x93, 0x82, 0xb3, 0x9b, 0xf8, 0x97, 0xd5, 0xac, 0xbd, 0xbb, 0xa9, 0x38, 0xc0, 0x4f, 0xff, 0x28,
	0x4b, 0x82, 0xd6, 0x62, 0x15, 0x33, 0x41, 0xce, 0xa1, 0xad, 0x2f, 0xdf, 0xc6, 0xcc, 0xf5, 0x5e,
	0xe3, 0x9b, 0x1d, 0xea, 0x71, 0x09, 0x8d, 0x14, 0x1e, 0xda, 0xfa, 0x13, 0xe4, 0x1d, 0xa8, 0x8b,
	0x87, 0xf4, 0x3a, 0x4f, 0xb4, 0x73, 0x1a, 0xe1, 0x95, 0x0c, 0x67, 0x94, 0x2f, 0xdf, 0x39, 0x8c,
	0x3b, 0x5f, 0xc1, 0xc1, 0x96, 0xf8, 0x73, 0x07, 0x57, 0x33, 0x8d, 0xfd, 0xb3, 0x02, 0x70, 0x55,
	0xe6, 0x9c, 0x45, 0xf2, 0x7d, 0xed, 0x40, 0x13, 0x1b, 0x94, 0xef, 0xa9, 0xe2, 0xaf, 0x30, 0xae,
	0x15, 0x54, 0x88, 0xfb, 0x9c, 0x47, 0x52, 0xa7, 0x15, 0xac, 0xb0, 0x34, 0x9b, 0x8a, 0xb9, 0xba,
	0x32, 0x4e, 0xa0, 0x00, 0x39, 0x81, 0x3a, 0x0d, 0x43, 0x26, 0xf0, 0x0e, 0xa0, 0x2f, 0x87, 0xd2,
	0x97, 0xf5, 0xe7, 0x06, 0x23, 0xb9, 0xaa, 0x2c, 0xd1, 0xa5, 0xe4, 0x63, 0xa8, 0xe2, 0x7f, 0x80,
	0x57, 0x33, 0x8e, 0xc2, 0xa0, 0x7c, 0x43, 0x4b, 0xaa, 0x08, 0xb2, 0xac, 0x73, 0x01, 0xae, 0xa1,
	0xb2, 0xa3, 0xf7, 0xe3, 0xcd, 0x99, 0x73, 0xa5, 0xa0, 0xa2, 0x98, 0x13, 0xfc, 0x29, 0x38, 0x2b,
	0xe9, 0x37, 0x19, 0x7d, 0xff, 0x0f, 0x0b, 0xda, 0x6a, 0x7f, 0xfa, 0x24, 0x9e, 0x78, 0xbb, 0x77,
	0xfc, 0x55, 0x91, 0x4f, 0x74, 0xbf, 0xb6, 0xf1, 0xcc, 0x6d, 0xe8, 0x6d, 0xb5, 0xfc, 0xe2, 0xad,
	0x9e, 0x42, 0x5d, 0x35, 0x8e, 0x35, 0xea, 0x8d, 0x46, 0x5e, 0x3b, 0x50, 0x00, 0xb3, 0xea, 0x71,
	0x46, 0x66, 0x35, 0x50, 0xe0, 0xeb, 0xfd, 0xbf, 0x1e, 0xbb, 0xd6, 0xdf, 0x8f, 0x5d, 0xeb, 0xdf,
	0xc7, 0xae, 0xf5, 0xdb, 0x7f, 0xdd, 0xb7, 0xae, 0xeb, 0xf2, 0xff, 0xf9, 0xe4, 0x55, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x8b, 0xe7, 0x09, 0xdc, 0xad, 0x07, 0x00, 0x00,
}
