// Code generated by protoc-gen-gogo.
// source: ultimateq.proto
// DO NOT EDIT!

package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SelfResponse struct {
	User  *SimpleUser   `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Modes *ChannelModes `protobuf:"bytes,2,opt,name=modes" json:"modes,omitempty"`
}

func (m *SelfResponse) Reset()                    { *m = SelfResponse{} }
func (m *SelfResponse) String() string            { return proto.CompactTextString(m) }
func (*SelfResponse) ProtoMessage()               {}
func (*SelfResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{0} }

func (m *SelfResponse) GetUser() *SimpleUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SelfResponse) GetModes() *ChannelModes {
	if m != nil {
		return m.Modes
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{1} }

type Result struct {
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{2} }

type Query struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *Query) Reset()                    { *m = Query{} }
func (m *Query) String() string            { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()               {}
func (*Query) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{3} }

type NetworkQuery struct {
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Query   string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *NetworkQuery) Reset()                    { *m = NetworkQuery{} }
func (m *NetworkQuery) String() string            { return proto.CompactTextString(m) }
func (*NetworkQuery) ProtoMessage()               {}
func (*NetworkQuery) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{4} }

type ChannelQuery struct {
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Channel string `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel,omitempty"`
	Query   string `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *ChannelQuery) Reset()                    { *m = ChannelQuery{} }
func (m *ChannelQuery) String() string            { return proto.CompactTextString(m) }
func (*ChannelQuery) ProtoMessage()               {}
func (*ChannelQuery) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{5} }

type ListResponse struct {
	List []string `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{6} }

type CountResponse struct {
	Count int32 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *CountResponse) Reset()                    { *m = CountResponse{} }
func (m *CountResponse) String() string            { return proto.CompactTextString(m) }
func (*CountResponse) ProtoMessage()               {}
func (*CountResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{7} }

type RegisterRequest struct {
	Name     string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Handlers []*Handler `protobuf:"bytes,2,rep,name=handlers" json:"handlers,omitempty"`
	Cmds     []*Command `protobuf:"bytes,3,rep,name=cmds" json:"cmds,omitempty"`
}

func (m *RegisterRequest) Reset()                    { *m = RegisterRequest{} }
func (m *RegisterRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterRequest) ProtoMessage()               {}
func (*RegisterRequest) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{8} }

func (m *RegisterRequest) GetHandlers() []*Handler {
	if m != nil {
		return m.Handlers
	}
	return nil
}

func (m *RegisterRequest) GetCmds() []*Command {
	if m != nil {
		return m.Cmds
	}
	return nil
}

type UnregisterRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *UnregisterRequest) Reset()                    { *m = UnregisterRequest{} }
func (m *UnregisterRequest) String() string            { return proto.CompactTextString(m) }
func (*UnregisterRequest) ProtoMessage()               {}
func (*UnregisterRequest) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{9} }

type UserResponse struct {
	Self *SimpleUser `protobuf:"bytes,1,opt,name=self" json:"self,omitempty"`
}

func (m *UserResponse) Reset()                    { *m = UserResponse{} }
func (m *UserResponse) String() string            { return proto.CompactTextString(m) }
func (*UserResponse) ProtoMessage()               {}
func (*UserResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{10} }

func (m *UserResponse) GetSelf() *SimpleUser {
	if m != nil {
		return m.Self
	}
	return nil
}

type UserModesResponse struct {
	Modes *ChannelModes `protobuf:"bytes,1,opt,name=modes" json:"modes,omitempty"`
}

func (m *UserModesResponse) Reset()                    { *m = UserModesResponse{} }
func (m *UserModesResponse) String() string            { return proto.CompactTextString(m) }
func (*UserModesResponse) ProtoMessage()               {}
func (*UserModesResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{11} }

func (m *UserModesResponse) GetModes() *ChannelModes {
	if m != nil {
		return m.Modes
	}
	return nil
}

type ChannelResponse struct {
	Name  string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Topic string        `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`
	Modes *ChannelModes `protobuf:"bytes,3,opt,name=modes" json:"modes,omitempty"`
}

func (m *ChannelResponse) Reset()                    { *m = ChannelResponse{} }
func (m *ChannelResponse) String() string            { return proto.CompactTextString(m) }
func (*ChannelResponse) ProtoMessage()               {}
func (*ChannelResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{12} }

func (m *ChannelResponse) GetModes() *ChannelModes {
	if m != nil {
		return m.Modes
	}
	return nil
}

type StoredUsersResponse struct {
	Users []*StoredUser `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
}

func (m *StoredUsersResponse) Reset()                    { *m = StoredUsersResponse{} }
func (m *StoredUsersResponse) String() string            { return proto.CompactTextString(m) }
func (*StoredUsersResponse) ProtoMessage()               {}
func (*StoredUsersResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{13} }

func (m *StoredUsersResponse) GetUsers() []*StoredUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type StoredChannelsResponse struct {
	Channels []*StoredChannel `protobuf:"bytes,1,rep,name=channels" json:"channels,omitempty"`
}

func (m *StoredChannelsResponse) Reset()                    { *m = StoredChannelsResponse{} }
func (m *StoredChannelsResponse) String() string            { return proto.CompactTextString(m) }
func (*StoredChannelsResponse) ProtoMessage()               {}
func (*StoredChannelsResponse) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{14} }

func (m *StoredChannelsResponse) GetChannels() []*StoredChannel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type LogoutRequest struct {
	// Types that are valid to be assigned to Query:
	//	*LogoutRequest_HostUser_
	//	*LogoutRequest_Username
	Query isLogoutRequest_Query `protobuf_oneof:"query"`
}

func (m *LogoutRequest) Reset()                    { *m = LogoutRequest{} }
func (m *LogoutRequest) String() string            { return proto.CompactTextString(m) }
func (*LogoutRequest) ProtoMessage()               {}
func (*LogoutRequest) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{15} }

type isLogoutRequest_Query interface {
	isLogoutRequest_Query()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LogoutRequest_HostUser_ struct {
	HostUser *LogoutRequest_HostUser `protobuf:"bytes,1,opt,name=host_user,json=hostUser,oneof"`
}
type LogoutRequest_Username struct {
	Username string `protobuf:"bytes,2,opt,name=username,proto3,oneof"`
}

func (*LogoutRequest_HostUser_) isLogoutRequest_Query() {}
func (*LogoutRequest_Username) isLogoutRequest_Query()  {}

func (m *LogoutRequest) GetQuery() isLogoutRequest_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *LogoutRequest) GetHostUser() *LogoutRequest_HostUser {
	if x, ok := m.GetQuery().(*LogoutRequest_HostUser_); ok {
		return x.HostUser
	}
	return nil
}

func (m *LogoutRequest) GetUsername() string {
	if x, ok := m.GetQuery().(*LogoutRequest_Username); ok {
		return x.Username
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LogoutRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LogoutRequest_OneofMarshaler, _LogoutRequest_OneofUnmarshaler, _LogoutRequest_OneofSizer, []interface{}{
		(*LogoutRequest_HostUser_)(nil),
		(*LogoutRequest_Username)(nil),
	}
}

func _LogoutRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LogoutRequest)
	// query
	switch x := m.Query.(type) {
	case *LogoutRequest_HostUser_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HostUser); err != nil {
			return err
		}
	case *LogoutRequest_Username:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Username)
	case nil:
	default:
		return fmt.Errorf("LogoutRequest.Query has unexpected type %T", x)
	}
	return nil
}

func _LogoutRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LogoutRequest)
	switch tag {
	case 1: // query.host_user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogoutRequest_HostUser)
		err := b.DecodeMessage(msg)
		m.Query = &LogoutRequest_HostUser_{msg}
		return true, err
	case 2: // query.username
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Query = &LogoutRequest_Username{x}
		return true, err
	default:
		return false, nil
	}
}

func _LogoutRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LogoutRequest)
	// query
	switch x := m.Query.(type) {
	case *LogoutRequest_HostUser_:
		s := proto.Size(x.HostUser)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogoutRequest_Username:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Username)))
		n += len(x.Username)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LogoutRequest_HostUser struct {
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Host    string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
}

func (m *LogoutRequest_HostUser) Reset()         { *m = LogoutRequest_HostUser{} }
func (m *LogoutRequest_HostUser) String() string { return proto.CompactTextString(m) }
func (*LogoutRequest_HostUser) ProtoMessage()    {}
func (*LogoutRequest_HostUser) Descriptor() ([]byte, []int) {
	return fileDescriptorUltimateq, []int{15, 0}
}

type IRCMessage struct {
	Name      string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sender    string   `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	Args      []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	Date      int64    `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
	NetworkId string   `protobuf:"bytes,5,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
}

func (m *IRCMessage) Reset()                    { *m = IRCMessage{} }
func (m *IRCMessage) String() string            { return proto.CompactTextString(m) }
func (*IRCMessage) ProtoMessage()               {}
func (*IRCMessage) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{16} }

type NetworkInfo struct {
	ServerName  string            `protobuf:"bytes,1,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	IrcdVersion string            `protobuf:"bytes,2,opt,name=ircd_version,json=ircdVersion,proto3" json:"ircd_version,omitempty"`
	Usermodes   string            `protobuf:"bytes,3,opt,name=usermodes,proto3" json:"usermodes,omitempty"`
	Lchanmodes  string            `protobuf:"bytes,4,opt,name=lchanmodes,proto3" json:"lchanmodes,omitempty"`
	Rfc         string            `protobuf:"bytes,5,opt,name=rfc,proto3" json:"rfc,omitempty"`
	Ircd        string            `protobuf:"bytes,6,opt,name=ircd,proto3" json:"ircd,omitempty"`
	Casemapping string            `protobuf:"bytes,7,opt,name=casemapping,proto3" json:"casemapping,omitempty"`
	Prefix      string            `protobuf:"bytes,8,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Chantypes   string            `protobuf:"bytes,9,opt,name=chantypes,proto3" json:"chantypes,omitempty"`
	Chanmodes   string            `protobuf:"bytes,10,opt,name=chanmodes,proto3" json:"chanmodes,omitempty"`
	Chanlimit   int32             `protobuf:"varint,11,opt,name=chanlimit,proto3" json:"chanlimit,omitempty"`
	Channellen  int32             `protobuf:"varint,12,opt,name=channellen,proto3" json:"channellen,omitempty"`
	Nicklen     int32             `protobuf:"varint,13,opt,name=nicklen,proto3" json:"nicklen,omitempty"`
	Topiclen    int32             `protobuf:"varint,14,opt,name=topiclen,proto3" json:"topiclen,omitempty"`
	Awaylen     int32             `protobuf:"varint,15,opt,name=awaylen,proto3" json:"awaylen,omitempty"`
	Kicklen     int32             `protobuf:"varint,16,opt,name=kicklen,proto3" json:"kicklen,omitempty"`
	Modes       int32             `protobuf:"varint,17,opt,name=modes,proto3" json:"modes,omitempty"`
	Extras      map[string]string `protobuf:"bytes,18,rep,name=extras" json:"extras,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NetworkInfo) Reset()                    { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()               {}
func (*NetworkInfo) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{17} }

func (m *NetworkInfo) GetExtras() map[string]string {
	if m != nil {
		return m.Extras
	}
	return nil
}

type AuthUserRequest struct {
	Network   string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Host      string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Username  string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	Password  string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	Permanent bool   `protobuf:"varint,5,opt,name=permanent,proto3" json:"permanent,omitempty"`
}

func (m *AuthUserRequest) Reset()                    { *m = AuthUserRequest{} }
func (m *AuthUserRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthUserRequest) ProtoMessage()               {}
func (*AuthUserRequest) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{18} }

type RawIRC struct {
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *RawIRC) Reset()                    { *m = RawIRC{} }
func (m *RawIRC) String() string            { return proto.CompactTextString(m) }
func (*RawIRC) ProtoMessage()               {}
func (*RawIRC) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{19} }

type ConnectionDetails struct {
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *ConnectionDetails) Reset()                    { *m = ConnectionDetails{} }
func (m *ConnectionDetails) String() string            { return proto.CompactTextString(m) }
func (*ConnectionDetails) ProtoMessage()               {}
func (*ConnectionDetails) Descriptor() ([]byte, []int) { return fileDescriptorUltimateq, []int{20} }

func init() {
	proto.RegisterType((*SelfResponse)(nil), "api.SelfResponse")
	proto.RegisterType((*Empty)(nil), "api.Empty")
	proto.RegisterType((*Result)(nil), "api.Result")
	proto.RegisterType((*Query)(nil), "api.Query")
	proto.RegisterType((*NetworkQuery)(nil), "api.NetworkQuery")
	proto.RegisterType((*ChannelQuery)(nil), "api.ChannelQuery")
	proto.RegisterType((*ListResponse)(nil), "api.ListResponse")
	proto.RegisterType((*CountResponse)(nil), "api.CountResponse")
	proto.RegisterType((*RegisterRequest)(nil), "api.RegisterRequest")
	proto.RegisterType((*UnregisterRequest)(nil), "api.UnregisterRequest")
	proto.RegisterType((*UserResponse)(nil), "api.UserResponse")
	proto.RegisterType((*UserModesResponse)(nil), "api.UserModesResponse")
	proto.RegisterType((*ChannelResponse)(nil), "api.ChannelResponse")
	proto.RegisterType((*StoredUsersResponse)(nil), "api.StoredUsersResponse")
	proto.RegisterType((*StoredChannelsResponse)(nil), "api.StoredChannelsResponse")
	proto.RegisterType((*LogoutRequest)(nil), "api.LogoutRequest")
	proto.RegisterType((*LogoutRequest_HostUser)(nil), "api.LogoutRequest.HostUser")
	proto.RegisterType((*IRCMessage)(nil), "api.IRCMessage")
	proto.RegisterType((*NetworkInfo)(nil), "api.NetworkInfo")
	proto.RegisterType((*AuthUserRequest)(nil), "api.AuthUserRequest")
	proto.RegisterType((*RawIRC)(nil), "api.RawIRC")
	proto.RegisterType((*ConnectionDetails)(nil), "api.ConnectionDetails")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Ext service

type ExtClient interface {
	Pipe(ctx context.Context, opts ...grpc.CallOption) (Ext_PipeClient, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*Empty, error)
	Unregister(ctx context.Context, in *UnregisterRequest, opts ...grpc.CallOption) (*Empty, error)
	StateSelf(ctx context.Context, in *Query, opts ...grpc.CallOption) (*SelfResponse, error)
	StateUser(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*SimpleUser, error)
	StateUsersByChan(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*ListResponse, error)
	StateUsersByChanCount(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*CountResponse, error)
	StateUserModes(ctx context.Context, in *ChannelQuery, opts ...grpc.CallOption) (*UserModes, error)
	StateChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*ChannelResponse, error)
	StateChannels(ctx context.Context, in *Query, opts ...grpc.CallOption) (*ListResponse, error)
	StateChannelCount(ctx context.Context, in *Query, opts ...grpc.CallOption) (*CountResponse, error)
	StateIsOn(ctx context.Context, in *ChannelQuery, opts ...grpc.CallOption) (*Result, error)
	StoreAuthUser(ctx context.Context, in *AuthUserRequest, opts ...grpc.CallOption) (*Empty, error)
	StoreAuthedUser(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*StoredUser, error)
	StoreUser(ctx context.Context, in *Query, opts ...grpc.CallOption) (*StoredUser, error)
	StoreUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StoredUsersResponse, error)
	StoreUsersByNetwork(ctx context.Context, in *Query, opts ...grpc.CallOption) (*StoredUsersResponse, error)
	StoreUsersByChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*StoredUsersResponse, error)
	StoreChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*StoredChannel, error)
	StoreChannels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StoredChannelsResponse, error)
	StorePutUser(ctx context.Context, in *StoredUser, opts ...grpc.CallOption) (*Empty, error)
	StorePutChannel(ctx context.Context, in *StoredChannel, opts ...grpc.CallOption) (*Empty, error)
	StoreDeleteUser(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Empty, error)
	StoreDeleteChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*Empty, error)
	StoreLogout(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*Empty, error)
	StoreLogoutByUser(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Empty, error)
}

type extClient struct {
	cc *grpc.ClientConn
}

func NewExtClient(cc *grpc.ClientConn) ExtClient {
	return &extClient{cc}
}

func (c *extClient) Pipe(ctx context.Context, opts ...grpc.CallOption) (Ext_PipeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Ext_serviceDesc.Streams[0], c.cc, "/api.Ext/Pipe", opts...)
	if err != nil {
		return nil, err
	}
	x := &extPipeClient{stream}
	return x, nil
}

type Ext_PipeClient interface {
	Send(*RawIRC) error
	Recv() (*IRCMessage, error)
	grpc.ClientStream
}

type extPipeClient struct {
	grpc.ClientStream
}

func (x *extPipeClient) Send(m *RawIRC) error {
	return x.ClientStream.SendMsg(m)
}

func (x *extPipeClient) Recv() (*IRCMessage, error) {
	m := new(IRCMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *extClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) Unregister(ctx context.Context, in *UnregisterRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/Unregister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateSelf(ctx context.Context, in *Query, opts ...grpc.CallOption) (*SelfResponse, error) {
	out := new(SelfResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StateSelf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateUser(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*SimpleUser, error) {
	out := new(SimpleUser)
	err := grpc.Invoke(ctx, "/api.Ext/StateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateUsersByChan(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StateUsersByChan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateUsersByChanCount(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*CountResponse, error) {
	out := new(CountResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StateUsersByChanCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateUserModes(ctx context.Context, in *ChannelQuery, opts ...grpc.CallOption) (*UserModes, error) {
	out := new(UserModes)
	err := grpc.Invoke(ctx, "/api.Ext/StateUserModes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*ChannelResponse, error) {
	out := new(ChannelResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StateChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateChannels(ctx context.Context, in *Query, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StateChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateChannelCount(ctx context.Context, in *Query, opts ...grpc.CallOption) (*CountResponse, error) {
	out := new(CountResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StateChannelCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StateIsOn(ctx context.Context, in *ChannelQuery, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/api.Ext/StateIsOn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreAuthUser(ctx context.Context, in *AuthUserRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/StoreAuthUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreAuthedUser(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*StoredUser, error) {
	out := new(StoredUser)
	err := grpc.Invoke(ctx, "/api.Ext/StoreAuthedUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreUser(ctx context.Context, in *Query, opts ...grpc.CallOption) (*StoredUser, error) {
	out := new(StoredUser)
	err := grpc.Invoke(ctx, "/api.Ext/StoreUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StoredUsersResponse, error) {
	out := new(StoredUsersResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StoreUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreUsersByNetwork(ctx context.Context, in *Query, opts ...grpc.CallOption) (*StoredUsersResponse, error) {
	out := new(StoredUsersResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StoreUsersByNetwork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreUsersByChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*StoredUsersResponse, error) {
	out := new(StoredUsersResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StoreUsersByChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*StoredChannel, error) {
	out := new(StoredChannel)
	err := grpc.Invoke(ctx, "/api.Ext/StoreChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreChannels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StoredChannelsResponse, error) {
	out := new(StoredChannelsResponse)
	err := grpc.Invoke(ctx, "/api.Ext/StoreChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StorePutUser(ctx context.Context, in *StoredUser, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/StorePutUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StorePutChannel(ctx context.Context, in *StoredChannel, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/StorePutChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreDeleteUser(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/StoreDeleteUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreDeleteChannel(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/StoreDeleteChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreLogout(ctx context.Context, in *NetworkQuery, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/StoreLogout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extClient) StoreLogoutByUser(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Ext/StoreLogoutByUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Ext service

type ExtServer interface {
	Pipe(Ext_PipeServer) error
	Register(context.Context, *RegisterRequest) (*Empty, error)
	Unregister(context.Context, *UnregisterRequest) (*Empty, error)
	StateSelf(context.Context, *Query) (*SelfResponse, error)
	StateUser(context.Context, *NetworkQuery) (*SimpleUser, error)
	StateUsersByChan(context.Context, *NetworkQuery) (*ListResponse, error)
	StateUsersByChanCount(context.Context, *NetworkQuery) (*CountResponse, error)
	StateUserModes(context.Context, *ChannelQuery) (*UserModes, error)
	StateChannel(context.Context, *NetworkQuery) (*ChannelResponse, error)
	StateChannels(context.Context, *Query) (*ListResponse, error)
	StateChannelCount(context.Context, *Query) (*CountResponse, error)
	StateIsOn(context.Context, *ChannelQuery) (*Result, error)
	StoreAuthUser(context.Context, *AuthUserRequest) (*Empty, error)
	StoreAuthedUser(context.Context, *NetworkQuery) (*StoredUser, error)
	StoreUser(context.Context, *Query) (*StoredUser, error)
	StoreUsers(context.Context, *Empty) (*StoredUsersResponse, error)
	StoreUsersByNetwork(context.Context, *Query) (*StoredUsersResponse, error)
	StoreUsersByChannel(context.Context, *NetworkQuery) (*StoredUsersResponse, error)
	StoreChannel(context.Context, *NetworkQuery) (*StoredChannel, error)
	StoreChannels(context.Context, *Empty) (*StoredChannelsResponse, error)
	StorePutUser(context.Context, *StoredUser) (*Empty, error)
	StorePutChannel(context.Context, *StoredChannel) (*Empty, error)
	StoreDeleteUser(context.Context, *Query) (*Empty, error)
	StoreDeleteChannel(context.Context, *NetworkQuery) (*Empty, error)
	StoreLogout(context.Context, *NetworkQuery) (*Empty, error)
	StoreLogoutByUser(context.Context, *Query) (*Empty, error)
}

func RegisterExtServer(s *grpc.Server, srv ExtServer) {
	s.RegisterService(&_Ext_serviceDesc, srv)
}

func _Ext_Pipe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExtServer).Pipe(&extPipeServer{stream})
}

type Ext_PipeServer interface {
	Send(*IRCMessage) error
	Recv() (*RawIRC, error)
	grpc.ServerStream
}

type extPipeServer struct {
	grpc.ServerStream
}

func (x *extPipeServer) Send(m *IRCMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *extPipeServer) Recv() (*RawIRC, error) {
	m := new(RawIRC)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Ext_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_Unregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).Unregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/Unregister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).Unregister(ctx, req.(*UnregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateSelf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateSelf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateSelf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateSelf(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateUser(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateUsersByChan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateUsersByChan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateUsersByChan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateUsersByChan(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateUsersByChanCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateUsersByChanCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateUsersByChanCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateUsersByChanCount(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateUserModes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateUserModes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateUserModes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateUserModes(ctx, req.(*ChannelQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateChannel(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateChannels(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateChannelCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateChannelCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateChannelCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateChannelCount(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StateIsOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StateIsOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StateIsOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StateIsOn(ctx, req.(*ChannelQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreAuthUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreAuthUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreAuthUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreAuthUser(ctx, req.(*AuthUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreAuthedUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreAuthedUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreAuthedUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreAuthedUser(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreUser(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreUsers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreUsersByNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreUsersByNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreUsersByNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreUsersByNetwork(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreUsersByChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreUsersByChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreUsersByChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreUsersByChannel(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreChannel(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreChannels(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StorePutUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoredUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StorePutUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StorePutUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StorePutUser(ctx, req.(*StoredUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StorePutChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoredChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StorePutChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StorePutChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StorePutChannel(ctx, req.(*StoredChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreDeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreDeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreDeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreDeleteUser(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreDeleteChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreDeleteChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreDeleteChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreDeleteChannel(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreLogout(ctx, req.(*NetworkQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ext_StoreLogoutByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtServer).StoreLogoutByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Ext/StoreLogoutByUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtServer).StoreLogoutByUser(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ext_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Ext",
	HandlerType: (*ExtServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Ext_Register_Handler,
		},
		{
			MethodName: "Unregister",
			Handler:    _Ext_Unregister_Handler,
		},
		{
			MethodName: "StateSelf",
			Handler:    _Ext_StateSelf_Handler,
		},
		{
			MethodName: "StateUser",
			Handler:    _Ext_StateUser_Handler,
		},
		{
			MethodName: "StateUsersByChan",
			Handler:    _Ext_StateUsersByChan_Handler,
		},
		{
			MethodName: "StateUsersByChanCount",
			Handler:    _Ext_StateUsersByChanCount_Handler,
		},
		{
			MethodName: "StateUserModes",
			Handler:    _Ext_StateUserModes_Handler,
		},
		{
			MethodName: "StateChannel",
			Handler:    _Ext_StateChannel_Handler,
		},
		{
			MethodName: "StateChannels",
			Handler:    _Ext_StateChannels_Handler,
		},
		{
			MethodName: "StateChannelCount",
			Handler:    _Ext_StateChannelCount_Handler,
		},
		{
			MethodName: "StateIsOn",
			Handler:    _Ext_StateIsOn_Handler,
		},
		{
			MethodName: "StoreAuthUser",
			Handler:    _Ext_StoreAuthUser_Handler,
		},
		{
			MethodName: "StoreAuthedUser",
			Handler:    _Ext_StoreAuthedUser_Handler,
		},
		{
			MethodName: "StoreUser",
			Handler:    _Ext_StoreUser_Handler,
		},
		{
			MethodName: "StoreUsers",
			Handler:    _Ext_StoreUsers_Handler,
		},
		{
			MethodName: "StoreUsersByNetwork",
			Handler:    _Ext_StoreUsersByNetwork_Handler,
		},
		{
			MethodName: "StoreUsersByChannel",
			Handler:    _Ext_StoreUsersByChannel_Handler,
		},
		{
			MethodName: "StoreChannel",
			Handler:    _Ext_StoreChannel_Handler,
		},
		{
			MethodName: "StoreChannels",
			Handler:    _Ext_StoreChannels_Handler,
		},
		{
			MethodName: "StorePutUser",
			Handler:    _Ext_StorePutUser_Handler,
		},
		{
			MethodName: "StorePutChannel",
			Handler:    _Ext_StorePutChannel_Handler,
		},
		{
			MethodName: "StoreDeleteUser",
			Handler:    _Ext_StoreDeleteUser_Handler,
		},
		{
			MethodName: "StoreDeleteChannel",
			Handler:    _Ext_StoreDeleteChannel_Handler,
		},
		{
			MethodName: "StoreLogout",
			Handler:    _Ext_StoreLogout_Handler,
		},
		{
			MethodName: "StoreLogoutByUser",
			Handler:    _Ext_StoreLogoutByUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Pipe",
			Handler:       _Ext_Pipe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptorUltimateq,
}

// Client API for Boomerang service

type BoomerangClient interface {
	Connect(ctx context.Context, in *ConnectionDetails, opts ...grpc.CallOption) (*Empty, error)
}

type boomerangClient struct {
	cc *grpc.ClientConn
}

func NewBoomerangClient(cc *grpc.ClientConn) BoomerangClient {
	return &boomerangClient{cc}
}

func (c *boomerangClient) Connect(ctx context.Context, in *ConnectionDetails, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.Boomerang/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Boomerang service

type BoomerangServer interface {
	Connect(context.Context, *ConnectionDetails) (*Empty, error)
}

func RegisterBoomerangServer(s *grpc.Server, srv BoomerangServer) {
	s.RegisterService(&_Boomerang_serviceDesc, srv)
}

func _Boomerang_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectionDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoomerangServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Boomerang/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoomerangServer).Connect(ctx, req.(*ConnectionDetails))
	}
	return interceptor(ctx, in, info, handler)
}

var _Boomerang_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Boomerang",
	HandlerType: (*BoomerangServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Boomerang_Connect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorUltimateq,
}

func (m *SelfResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SelfResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.User.Size()))
		n1, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Modes != nil {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Modes.Size()))
		n2, err := m.Modes.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Empty) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Empty) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Result) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Result) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		data[i] = 0x8
		i++
		if m.Ok {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Query) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Query) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	return i, nil
}

func (m *NetworkQuery) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NetworkQuery) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Query) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	return i, nil
}

func (m *ChannelQuery) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelQuery) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Channel) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Channel)))
		i += copy(data[i:], m.Channel)
	}
	if len(m.Query) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	return i, nil
}

func (m *ListResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, s := range m.List {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CountResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CountResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *RegisterRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisterRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Handlers) > 0 {
		for _, msg := range m.Handlers {
			data[i] = 0x12
			i++
			i = encodeVarintUltimateq(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cmds) > 0 {
		for _, msg := range m.Cmds {
			data[i] = 0x1a
			i++
			i = encodeVarintUltimateq(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UnregisterRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnregisterRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *UserResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Self != nil {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Self.Size()))
		n3, err := m.Self.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *UserModesResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserModesResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Modes != nil {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Modes.Size()))
		n4, err := m.Modes.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ChannelResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Topic) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Topic)))
		i += copy(data[i:], m.Topic)
	}
	if m.Modes != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Modes.Size()))
		n5, err := m.Modes.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *StoredUsersResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StoredUsersResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			data[i] = 0xa
			i++
			i = encodeVarintUltimateq(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StoredChannelsResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StoredChannelsResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, msg := range m.Channels {
			data[i] = 0xa
			i++
			i = encodeVarintUltimateq(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LogoutRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LogoutRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Query != nil {
		nn6, err := m.Query.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	return i, nil
}

func (m *LogoutRequest_HostUser_) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.HostUser != nil {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.HostUser.Size()))
		n7, err := m.HostUser.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *LogoutRequest_Username) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x12
	i++
	i = encodeVarintUltimateq(data, i, uint64(len(m.Username)))
	i += copy(data[i:], m.Username)
	return i, nil
}
func (m *LogoutRequest_HostUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LogoutRequest_HostUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Host) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	return i, nil
}

func (m *IRCMessage) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IRCMessage) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Sender) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Sender)))
		i += copy(data[i:], m.Sender)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Date != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Date))
	}
	if len(m.NetworkId) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.NetworkId)))
		i += copy(data[i:], m.NetworkId)
	}
	return i, nil
}

func (m *NetworkInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NetworkInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.ServerName)))
		i += copy(data[i:], m.ServerName)
	}
	if len(m.IrcdVersion) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.IrcdVersion)))
		i += copy(data[i:], m.IrcdVersion)
	}
	if len(m.Usermodes) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Usermodes)))
		i += copy(data[i:], m.Usermodes)
	}
	if len(m.Lchanmodes) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Lchanmodes)))
		i += copy(data[i:], m.Lchanmodes)
	}
	if len(m.Rfc) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Rfc)))
		i += copy(data[i:], m.Rfc)
	}
	if len(m.Ircd) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Ircd)))
		i += copy(data[i:], m.Ircd)
	}
	if len(m.Casemapping) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Casemapping)))
		i += copy(data[i:], m.Casemapping)
	}
	if len(m.Prefix) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Prefix)))
		i += copy(data[i:], m.Prefix)
	}
	if len(m.Chantypes) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Chantypes)))
		i += copy(data[i:], m.Chantypes)
	}
	if len(m.Chanmodes) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Chanmodes)))
		i += copy(data[i:], m.Chanmodes)
	}
	if m.Chanlimit != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Chanlimit))
	}
	if m.Channellen != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Channellen))
	}
	if m.Nicklen != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Nicklen))
	}
	if m.Topiclen != 0 {
		data[i] = 0x70
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Topiclen))
	}
	if m.Awaylen != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Awaylen))
	}
	if m.Kicklen != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Kicklen))
	}
	if m.Modes != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Modes))
	}
	if len(m.Extras) > 0 {
		for k, _ := range m.Extras {
			data[i] = 0x92
			i++
			data[i] = 0x1
			i++
			v := m.Extras[k]
			mapSize := 1 + len(k) + sovUltimateq(uint64(len(k))) + 1 + len(v) + sovUltimateq(uint64(len(v)))
			i = encodeVarintUltimateq(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintUltimateq(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintUltimateq(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *AuthUserRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthUserRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Network)))
		i += copy(data[i:], m.Network)
	}
	if len(m.Host) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.Username) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	if len(m.Password) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	if m.Permanent {
		data[i] = 0x28
		i++
		if m.Permanent {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RawIRC) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RawIRC) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Msg)))
		i += copy(data[i:], m.Msg)
	}
	return i, nil
}

func (m *ConnectionDetails) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConnectionDetails) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintUltimateq(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if m.Port != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintUltimateq(data, i, uint64(m.Port))
	}
	return i, nil
}

func encodeFixed64Ultimateq(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Ultimateq(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintUltimateq(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *SelfResponse) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovUltimateq(uint64(l))
	}
	if m.Modes != nil {
		l = m.Modes.Size()
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Result) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	return n
}

func (m *Query) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *NetworkQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *ChannelQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, s := range m.List {
			l = len(s)
			n += 1 + l + sovUltimateq(uint64(l))
		}
	}
	return n
}

func (m *CountResponse) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovUltimateq(uint64(m.Count))
	}
	return n
}

func (m *RegisterRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	if len(m.Handlers) > 0 {
		for _, e := range m.Handlers {
			l = e.Size()
			n += 1 + l + sovUltimateq(uint64(l))
		}
	}
	if len(m.Cmds) > 0 {
		for _, e := range m.Cmds {
			l = e.Size()
			n += 1 + l + sovUltimateq(uint64(l))
		}
	}
	return n
}

func (m *UnregisterRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *UserResponse) Size() (n int) {
	var l int
	_ = l
	if m.Self != nil {
		l = m.Self.Size()
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *UserModesResponse) Size() (n int) {
	var l int
	_ = l
	if m.Modes != nil {
		l = m.Modes.Size()
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *ChannelResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	if m.Modes != nil {
		l = m.Modes.Size()
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *StoredUsersResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovUltimateq(uint64(l))
		}
	}
	return n
}

func (m *StoredChannelsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovUltimateq(uint64(l))
		}
	}
	return n
}

func (m *LogoutRequest) Size() (n int) {
	var l int
	_ = l
	if m.Query != nil {
		n += m.Query.Size()
	}
	return n
}

func (m *LogoutRequest_HostUser_) Size() (n int) {
	var l int
	_ = l
	if m.HostUser != nil {
		l = m.HostUser.Size()
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}
func (m *LogoutRequest_Username) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	n += 1 + l + sovUltimateq(uint64(l))
	return n
}
func (m *LogoutRequest_HostUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *IRCMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovUltimateq(uint64(l))
		}
	}
	if m.Date != 0 {
		n += 1 + sovUltimateq(uint64(m.Date))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *NetworkInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.IrcdVersion)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Usermodes)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Lchanmodes)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Rfc)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Ircd)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Casemapping)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Chantypes)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Chanmodes)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	if m.Chanlimit != 0 {
		n += 1 + sovUltimateq(uint64(m.Chanlimit))
	}
	if m.Channellen != 0 {
		n += 1 + sovUltimateq(uint64(m.Channellen))
	}
	if m.Nicklen != 0 {
		n += 1 + sovUltimateq(uint64(m.Nicklen))
	}
	if m.Topiclen != 0 {
		n += 1 + sovUltimateq(uint64(m.Topiclen))
	}
	if m.Awaylen != 0 {
		n += 1 + sovUltimateq(uint64(m.Awaylen))
	}
	if m.Kicklen != 0 {
		n += 2 + sovUltimateq(uint64(m.Kicklen))
	}
	if m.Modes != 0 {
		n += 2 + sovUltimateq(uint64(m.Modes))
	}
	if len(m.Extras) > 0 {
		for k, v := range m.Extras {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovUltimateq(uint64(len(k))) + 1 + len(v) + sovUltimateq(uint64(len(v)))
			n += mapEntrySize + 2 + sovUltimateq(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AuthUserRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	if m.Permanent {
		n += 2
	}
	return n
}

func (m *RawIRC) Size() (n int) {
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	return n
}

func (m *ConnectionDetails) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovUltimateq(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovUltimateq(uint64(m.Port))
	}
	return n
}

func sovUltimateq(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozUltimateq(x uint64) (n int) {
	return sovUltimateq(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SelfResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &SimpleUser{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modes == nil {
				m.Modes = &ChannelModes{}
			}
			if err := m.Modes.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkQuery) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelQuery) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handlers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handlers = append(m.Handlers, &Handler{})
			if err := m.Handlers[len(m.Handlers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmds = append(m.Cmds, &Command{})
			if err := m.Cmds[len(m.Cmds)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Self", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Self == nil {
				m.Self = &SimpleUser{}
			}
			if err := m.Self.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserModesResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserModesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserModesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modes == nil {
				m.Modes = &ChannelModes{}
			}
			if err := m.Modes.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modes == nil {
				m.Modes = &ChannelModes{}
			}
			if err := m.Modes.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoredUsersResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoredUsersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoredUsersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &StoredUser{})
			if err := m.Users[len(m.Users)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoredChannelsResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoredChannelsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoredChannelsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, &StoredChannel{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogoutRequest_HostUser{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Query = &LogoutRequest_HostUser_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = &LogoutRequest_Username{string(data[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutRequest_HostUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IRCMessage) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IRCMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IRCMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrcdVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IrcdVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usermodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usermodes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lchanmodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lchanmodes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rfc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rfc = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ircd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ircd = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Casemapping", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Casemapping = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chantypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chantypes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chanmodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chanmodes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chanlimit", wireType)
			}
			m.Chanlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Chanlimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channellen", wireType)
			}
			m.Channellen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Channellen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nicklen", wireType)
			}
			m.Nicklen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nicklen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topiclen", wireType)
			}
			m.Topiclen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Topiclen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Awaylen", wireType)
			}
			m.Awaylen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Awaylen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kicklen", wireType)
			}
			m.Kicklen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kicklen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			m.Modes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Modes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extras", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthUltimateq
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Extras == nil {
				m.Extras = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUltimateq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUltimateq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthUltimateq
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Extras[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Extras[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthUserRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permanent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Permanent = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawIRC) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawIRC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawIRC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], data[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionDetails) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUltimateq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUltimateq(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUltimateq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUltimateq(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUltimateq
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUltimateq
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthUltimateq
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowUltimateq
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipUltimateq(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthUltimateq = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUltimateq   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ultimateq.proto", fileDescriptorUltimateq) }

var fileDescriptorUltimateq = []byte{
	// 1332 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x57, 0xdd, 0x4e, 0x1b, 0xc7,
	0x17, 0xcf, 0x62, 0x1b, 0xec, 0x63, 0x83, 0xf1, 0xfc, 0xf9, 0x47, 0x2b, 0x27, 0xa1, 0x74, 0xab,
	0x28, 0x6e, 0x93, 0xd2, 0x04, 0x1a, 0x95, 0x26, 0x51, 0xa4, 0x42, 0x90, 0x40, 0x4a, 0xd2, 0x74,
	0x51, 0xaa, 0x5e, 0x54, 0x42, 0x53, 0xef, 0x60, 0x56, 0xec, 0xee, 0x2c, 0x33, 0xe3, 0x10, 0x5f,
	0xf5, 0x29, 0x2a, 0xf5, 0x21, 0xfa, 0x06, 0x7d, 0x81, 0x5e, 0xf6, 0xba, 0x57, 0x55, 0xfa, 0x22,
	0xd5, 0xcc, 0x99, 0xdd, 0x1d, 0x83, 0x01, 0xf5, 0x6e, 0xce, 0xc7, 0xef, 0x9c, 0x33, 0xe7, 0x63,
	0xce, 0x2e, 0x74, 0xc7, 0x89, 0x8a, 0x53, 0xaa, 0xd8, 0xe9, 0x7a, 0x2e, 0xb8, 0xe2, 0xa4, 0x46,
	0xf3, 0xb8, 0x0f, 0x11, 0x55, 0x14, 0x19, 0xc1, 0x8f, 0xd0, 0x39, 0x60, 0xc9, 0x51, 0xc8, 0x64,
	0xce, 0x33, 0xc9, 0xc8, 0x27, 0x50, 0x1f, 0x4b, 0x26, 0x7c, 0x6f, 0xcd, 0x1b, 0xb4, 0x37, 0xba,
	0xeb, 0x34, 0x8f, 0xd7, 0x0f, 0xe2, 0x34, 0x4f, 0xd8, 0x5b, 0xc9, 0x44, 0x68, 0x84, 0xe4, 0x1e,
	0x34, 0x52, 0x1e, 0x31, 0xe9, 0xcf, 0x19, 0xad, 0x9e, 0xd1, 0xda, 0x39, 0xa6, 0x59, 0xc6, 0x92,
	0x57, 0x5a, 0x10, 0xa2, 0x3c, 0x58, 0x80, 0xc6, 0x6e, 0x9a, 0xab, 0x49, 0xe0, 0xc3, 0x7c, 0xc8,
	0xe4, 0x38, 0x51, 0x64, 0x09, 0xe6, 0xf8, 0x89, 0x31, 0xdf, 0x0c, 0xe7, 0xf8, 0x49, 0x70, 0x07,
	0x1a, 0xdf, 0x8d, 0x99, 0x98, 0x90, 0x15, 0x68, 0x9c, 0xea, 0x83, 0x91, 0xb5, 0x42, 0x24, 0x82,
	0xe7, 0xd0, 0x79, 0xcd, 0xd4, 0x19, 0x17, 0x27, 0xa8, 0xe5, 0xc3, 0x42, 0x86, 0xb4, 0xd5, 0x2b,
	0xc8, 0x0a, 0x3f, 0xe7, 0xe2, 0x7f, 0x80, 0x8e, 0x0d, 0xec, 0x3a, 0xbc, 0x0f, 0x0b, 0x43, 0xd4,
	0xb4, 0x16, 0x0a, 0xb2, 0xb2, 0x5c, 0x73, 0x2d, 0x07, 0xd0, 0x79, 0x19, 0x4b, 0x55, 0x66, 0x8e,
	0x40, 0x3d, 0x89, 0xa5, 0xf2, 0xbd, 0xb5, 0xda, 0xa0, 0x15, 0x9a, 0x73, 0x70, 0x17, 0x16, 0x77,
	0xf8, 0x38, 0xab, 0x94, 0x56, 0xa0, 0x31, 0xd4, 0x0c, 0xe3, 0xbc, 0x11, 0x22, 0x11, 0x9c, 0x42,
	0x37, 0x64, 0xa3, 0x58, 0x2a, 0x26, 0x42, 0x76, 0x3a, 0x66, 0x52, 0x69, 0x6b, 0x19, 0x4d, 0x99,
	0x0d, 0xd2, 0x9c, 0xc9, 0x00, 0x9a, 0xc7, 0x34, 0x8b, 0x12, 0x26, 0x74, 0xe6, 0x6b, 0x83, 0xf6,
	0x46, 0xc7, 0x64, 0x7e, 0x0f, 0x99, 0x61, 0x29, 0x25, 0x6b, 0x50, 0x1f, 0xa6, 0x91, 0xf4, 0x6b,
	0x8e, 0xd6, 0x0e, 0x4f, 0x53, 0x9a, 0x45, 0xa1, 0x91, 0x04, 0xf7, 0xa0, 0xf7, 0x36, 0x13, 0xd7,
	0x3b, 0x0d, 0x36, 0xa1, 0x63, 0x2a, 0xef, 0x34, 0x88, 0x64, 0xc9, 0xd1, 0xa5, 0x0d, 0xa2, 0x85,
	0xc1, 0x33, 0xe8, 0x69, 0x0a, 0x7b, 0xa1, 0x40, 0x96, 0x5d, 0xe3, 0x5d, 0xd3, 0x35, 0x11, 0x74,
	0x2d, 0xdb, 0x4d, 0xee, 0x85, 0x74, 0xac, 0x40, 0x43, 0xf1, 0x3c, 0x1e, 0x16, 0x05, 0x37, 0x44,
	0xe5, 0xa5, 0x76, 0x8d, 0x97, 0x67, 0xf0, 0xbf, 0x03, 0xc5, 0x05, 0x8b, 0x74, 0xa4, 0x55, 0x94,
	0x77, 0xa1, 0xa1, 0x7b, 0x5c, 0x9a, 0x3a, 0x96, 0x17, 0x2c, 0x15, 0x43, 0x94, 0x06, 0x7b, 0x70,
	0x13, 0x99, 0xd6, 0x74, 0x65, 0x60, 0x1d, 0x9a, 0xb6, 0x71, 0x0a, 0x1b, 0xc4, 0xb1, 0x51, 0x5c,
	0xac, 0xd4, 0x09, 0x7e, 0xf3, 0x60, 0xf1, 0x25, 0x1f, 0xf1, 0xb1, 0x2a, 0xca, 0xf0, 0x04, 0x5a,
	0xc7, 0x5c, 0xaa, 0x43, 0x67, 0x10, 0x6f, 0x19, 0x13, 0x53, 0x6a, 0xeb, 0x7b, 0x5c, 0x2a, 0x1d,
	0xd2, 0xde, 0x8d, 0xb0, 0x79, 0x6c, 0xcf, 0xe4, 0x36, 0x34, 0x35, 0xcc, 0x24, 0xcb, 0xe4, 0x45,
	0x4b, 0x0b, 0x4e, 0x7f, 0x0b, 0x9a, 0x05, 0xea, 0x8a, 0x49, 0x20, 0x50, 0xd7, 0xf6, 0x6c, 0x5e,
	0xcd, 0x79, 0x7b, 0xc1, 0xce, 0x40, 0xf0, 0x33, 0xc0, 0x7e, 0xb8, 0xf3, 0x8a, 0x49, 0x49, 0x47,
	0xb3, 0xeb, 0x72, 0x13, 0xe6, 0x25, 0xcb, 0x22, 0x26, 0xac, 0x01, 0x4b, 0x69, 0x5d, 0x2a, 0x46,
	0xd8, 0x94, 0xad, 0xd0, 0x9c, 0x35, 0x2f, 0xa2, 0x8a, 0xf9, 0xf5, 0x35, 0x6f, 0x50, 0x0b, 0xcd,
	0x99, 0xdc, 0x01, 0xb0, 0x91, 0x1c, 0xc6, 0x91, 0xdf, 0x30, 0x36, 0x5a, 0x96, 0xb3, 0x1f, 0x05,
	0x7f, 0xd5, 0xa1, 0x6d, 0x9f, 0x84, 0xfd, 0xec, 0x88, 0x93, 0x8f, 0xa0, 0x2d, 0x99, 0x78, 0xc7,
	0xc4, 0xa1, 0x13, 0x09, 0x20, 0xeb, 0xb5, 0x8e, 0xe7, 0x63, 0xe8, 0xc4, 0x62, 0x18, 0x1d, 0xbe,
	0x63, 0x42, 0xc6, 0x3c, 0xb3, 0x51, 0xb5, 0x35, 0xef, 0x7b, 0x64, 0x91, 0xdb, 0xd0, 0xd2, 0x39,
	0xaa, 0x1a, 0xa7, 0x15, 0x56, 0x0c, 0xb2, 0x0a, 0x90, 0xe8, 0x72, 0xa1, 0xb8, 0x8e, 0x0e, 0x2a,
	0x0e, 0x59, 0x86, 0x9a, 0x38, 0x1a, 0xda, 0x48, 0xf5, 0x51, 0x5f, 0x4b, 0x9b, 0xf7, 0xe7, 0x31,
	0x2d, 0xfa, 0x4c, 0xd6, 0xa0, 0x3d, 0xa4, 0x92, 0xa5, 0x34, 0xcf, 0xe3, 0x6c, 0xe4, 0x2f, 0x60,
	0x14, 0x0e, 0x4b, 0x27, 0x2e, 0x17, 0xec, 0x28, 0x7e, 0xef, 0x37, 0x31, 0x71, 0x48, 0xe9, 0xe8,
	0xb4, 0x33, 0x35, 0xc9, 0x99, 0xf4, 0x5b, 0x18, 0x5d, 0xc9, 0x28, 0xa4, 0x18, 0x1c, 0x54, 0x52,
	0x8c, 0xcd, 0x4a, 0x93, 0x38, 0x8d, 0x95, 0xdf, 0x36, 0x8f, 0x4e, 0xc5, 0xd0, 0x37, 0xb3, 0x7d,
	0x98, 0xb0, 0xcc, 0xef, 0x18, 0xb1, 0xc3, 0x31, 0x3d, 0x12, 0x0f, 0x4f, 0xb4, 0x70, 0xd1, 0x08,
	0x0b, 0x92, 0xf4, 0xa1, 0x69, 0xe6, 0x4d, 0x8b, 0x96, 0x8c, 0xa8, 0xa4, 0x35, 0x8a, 0x9e, 0xd1,
	0x89, 0x16, 0x75, 0x11, 0x65, 0x49, 0x2d, 0x39, 0xb1, 0xf6, 0x96, 0x51, 0x62, 0x49, 0x3d, 0xcc,
	0x78, 0x83, 0x1e, 0x3e, 0x8c, 0x18, 0xfd, 0x97, 0x30, 0xcf, 0xde, 0x2b, 0x41, 0xa5, 0x4f, 0xcc,
	0x24, 0xdd, 0x36, 0x63, 0xe0, 0x54, 0x7f, 0x7d, 0xd7, 0x88, 0x77, 0x33, 0x25, 0x26, 0xa1, 0xd5,
	0xed, 0x7f, 0x0d, 0x6d, 0x87, 0xad, 0xcb, 0x73, 0xc2, 0x8a, 0xb5, 0xa2, 0x8f, 0xda, 0xd9, 0x3b,
	0x9a, 0x8c, 0x59, 0xf1, 0x72, 0x18, 0xe2, 0xc9, 0xdc, 0x96, 0x17, 0xfc, 0xe2, 0x41, 0xf7, 0x9b,
	0xb1, 0x3a, 0xc6, 0x27, 0x0f, 0xc7, 0xf1, 0x3f, 0x0d, 0x8a, 0x4e, 0x4c, 0x39, 0x80, 0xd8, 0x49,
	0x25, 0xad, 0x65, 0x39, 0x95, 0xf2, 0x8c, 0x8b, 0xc8, 0xb6, 0x51, 0x49, 0xeb, 0x42, 0xe5, 0x4c,
	0xa4, 0x34, 0x63, 0x99, 0x32, 0xad, 0xd4, 0x0c, 0x2b, 0x46, 0xd0, 0x87, 0xf9, 0x90, 0x9e, 0xed,
	0x87, 0x3b, 0xfa, 0x36, 0xa9, 0x1c, 0x99, 0x48, 0x3a, 0xa1, 0x3e, 0x06, 0x4f, 0xa1, 0xb7, 0xc3,
	0xb3, 0x8c, 0x0d, 0x55, 0xcc, 0xb3, 0x17, 0x4c, 0xd1, 0x38, 0x91, 0x65, 0x68, 0x9e, 0x13, 0x1a,
	0x81, 0x7a, 0xce, 0x05, 0x86, 0xdb, 0x08, 0xcd, 0x79, 0xe3, 0x77, 0x80, 0xda, 0xee, 0x7b, 0x45,
	0x06, 0x50, 0x7f, 0x13, 0xe7, 0x8c, 0xb4, 0x4d, 0x86, 0xd1, 0x57, 0x1f, 0x1f, 0xbf, 0x6a, 0xdc,
	0x07, 0xde, 0x43, 0x8f, 0x3c, 0x80, 0x66, 0xb1, 0xac, 0xc8, 0x0a, 0x6a, 0x4f, 0xaf, 0x91, 0x3e,
	0x18, 0xae, 0x59, 0xfc, 0xe4, 0x21, 0x40, 0xb5, 0x67, 0xc8, 0x4d, 0x23, 0xb9, 0xb0, 0x78, 0xa6,
	0x10, 0x9f, 0x41, 0xeb, 0x40, 0x51, 0xc5, 0xf4, 0x67, 0x09, 0x41, 0x81, 0x59, 0xdd, 0x7d, 0x7c,
	0xca, 0xa7, 0xbe, 0x56, 0xbe, 0xb0, 0xba, 0xe6, 0x41, 0xeb, 0xb9, 0xcd, 0x81, 0x90, 0xf3, 0xeb,
	0x89, 0x6c, 0xc1, 0x72, 0x09, 0x90, 0xdb, 0x13, 0xfd, 0x1a, 0xcf, 0xc2, 0x21, 0x6b, 0x6a, 0xbd,
	0x3f, 0x87, 0xff, 0x9f, 0x47, 0x9a, 0xd5, 0x3e, 0x0b, 0x4e, 0xec, 0xc2, 0x75, 0x37, 0xff, 0x26,
	0x2c, 0x95, 0x78, 0xb3, 0x87, 0xc8, 0xd4, 0x6a, 0x42, 0xe0, 0x12, 0xe6, 0xa7, 0x54, 0xf9, 0x0a,
	0x3a, 0x06, 0x64, 0x95, 0x66, 0xf9, 0x5a, 0x71, 0xad, 0x38, 0x4b, 0x68, 0xd1, 0x05, 0xca, 0x19,
	0x89, 0x9c, 0xba, 0xdd, 0x26, 0xf4, 0x5c, 0x7d, 0xbc, 0x99, 0x8b, 0x99, 0x75, 0xa5, 0xfb, 0x36,
	0xfb, 0xfb, 0xf2, 0xdb, 0x6c, 0xd6, 0x6d, 0x6c, 0x2f, 0xe1, 0x77, 0xdf, 0x23, 0x1d, 0x11, 0x17,
	0xac, 0x98, 0x2e, 0xdb, 0x3b, 0xe7, 0x86, 0x6d, 0xaa, 0x13, 0x1e, 0x43, 0xb7, 0x84, 0xe0, 0xf6,
	0xbd, 0xa2, 0xc6, 0xe5, 0x86, 0x26, 0x03, 0x1d, 0x16, 0x17, 0x58, 0x70, 0xf7, 0x0e, 0x17, 0x34,
	0x37, 0x00, 0x4a, 0xcd, 0x22, 0x45, 0xc6, 0x75, 0xdf, 0x3f, 0xa7, 0x5a, 0xad, 0xf7, 0xa7, 0xf6,
	0xb3, 0xc1, 0xf6, 0x81, 0x0d, 0x65, 0xca, 0xcf, 0xe5, 0xe0, 0xed, 0x69, 0xf0, 0x15, 0x65, 0xbd,
	0xdc, 0xc6, 0x63, 0xdd, 0x13, 0x5c, 0x5c, 0xd5, 0x13, 0x33, 0x3e, 0x38, 0xc8, 0x96, 0xcd, 0xff,
	0xb9, 0x8e, 0xc0, 0xeb, 0xde, 0xba, 0x08, 0x90, 0x4e, 0x99, 0xd1, 0xe1, 0x9b, 0x31, 0x7e, 0x38,
	0x9c, 0x4f, 0xe3, 0x54, 0xcd, 0x1e, 0xd9, 0x9a, 0xbd, 0x19, 0xab, 0xc2, 0xf3, 0x8c, 0x68, 0xa6,
	0x20, 0x9f, 0x5a, 0xc8, 0x0b, 0x96, 0x30, 0x75, 0xb1, 0x6a, 0xae, 0xea, 0x26, 0x10, 0x47, 0xf5,
	0x8a, 0x0c, 0xb8, 0xa0, 0x07, 0xd0, 0x36, 0x20, 0xfc, 0x7a, 0xba, 0x4e, 0xfb, 0xbe, 0x9e, 0x84,
	0x52, 0x7b, 0x7b, 0x72, 0x55, 0x3c, 0x1b, 0x4f, 0xa0, 0xb5, 0xcd, 0x79, 0xca, 0x04, 0xcd, 0x46,
	0xe4, 0x73, 0x58, 0xb0, 0xef, 0xb0, 0x7d, 0xe7, 0x2e, 0xbc, 0xca, 0x2e, 0x76, 0x7b, 0xf9, 0x8f,
	0x0f, 0xab, 0xde, 0x9f, 0x1f, 0x56, 0xbd, 0xbf, 0x3f, 0xac, 0x7a, 0xbf, 0xfe, 0xb3, 0x7a, 0xe3,
	0xa7, 0x79, 0xf3, 0x4b, 0xb6, 0xf9, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9e, 0xcb, 0x2a, 0x38,
	0xb6, 0x0d, 0x00, 0x00,
}
